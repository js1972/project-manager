<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project name — Gantt</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    :root {
      --row-h: 38px;
      --day-w: 24px;
      --scale-h: 44px;
      --left-w: 560px;
      --col-dep: 150px;
      --col-start: 110px;
      --col-end: 110px;
      --col-dur: 72px;
    }
    .gantt-grid-bg {
      background-image: linear-gradient(to right, rgba(0,0,0,0.06) 1px, transparent 1px);
      background-size: var(--day-w) 100%;
    }
    .weekend-shade { background-color: rgba(0,0,0,0.03); }
    .bar { cursor: grab; user-select: none; position:absolute; }
    .bar-label { position:absolute; top:0; bottom:0; left: 12px; right: 18px; display:flex; align-items:center; font-size: 12px; font-weight: 600; letter-spacing: 0.01em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; pointer-events: none; text-shadow: 0 1px 1px rgba(0,0,0,0.18); }
    .bar:active { cursor: grabbing; }
    .handle-l, .handle-r { position:absolute; top:0; width:10px; height:100%; opacity:0.9; }
    .handle-l { left:-5px; cursor: w-resize; }
    .handle-r { right:-5px; cursor: e-resize; }
    .milestone { width: 14px; height: 14px; transform: rotate(45deg); position:absolute; cursor: grab; user-select:none; }
    .drop-hover { outline: 2px dashed #4f46e5; outline-offset: -6px; }
    .scrollbar-thin::-webkit-scrollbar { height: 10px; width: 10px; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 6px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }

    /* Today indicator */
    .today-col { background-color: rgba(244, 63, 94, 0.08); }
    .today-line { position:absolute; width:2px; background:#f43f5e; opacity:0.9; }

    /* Limit shading: dates before min allowed */
    .limit-col { background: repeating-linear-gradient(45deg, rgba(220,38,38,0.08) 0 10px, rgba(220,38,38,0.16) 10px 20px); }

    /* Drag ghost */
    .dragging { opacity: 0.92; outline: 2px solid rgba(79,70,229,0.35); outline-offset: 2px; }

    /* Critical path */
    .bar.critical-bar { box-shadow: 0 0 0 2px rgba(244, 63, 94, 0.75), 0 8px 18px rgba(244, 63, 94, 0.25); }
    .milestone.critical-milestone { box-shadow: 0 0 0 2px rgba(244, 63, 94, 0.75), 0 8px 16px rgba(244, 63, 94, 0.25); }
    .critical-row .task-row-grid { box-shadow: inset 3px 0 0 rgba(244, 63, 94, 0.9); background: rgba(244, 63, 94, 0.04); }
    .non-critical { opacity: 0.6; filter: saturate(0.7); }

    /* Dependency link handle */
    .link-handle { position:absolute; width: 12px; height: 12px; border-radius: 999px; background: #ffffff; border: 2px solid #64748b; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18); cursor: crosshair; opacity: 0; transition: opacity 120ms ease; }
    .bar:hover .link-handle, .milestone-wrap:hover .link-handle { opacity: 1; }
    .bar .link-handle { right: -10px; top: 50%; transform: translate(50%, -50%); }
    .milestone-wrap { position:absolute; width:14px; height:14px; overflow: visible; }
    .milestone-wrap .link-handle { right: -10px; top: 50%; transform: translate(50%, -50%); }
    .link-target .task-row-grid { outline: 2px dashed rgba(245, 158, 11, 0.8); outline-offset: -2px; }
    body.linking { cursor: crosshair; }

    /* Notes */
    .note-btn { width: 20px; height: 20px; border-radius: 6px; font-size: 10px; font-weight: 700; color: rgba(0,0,0,0.45); background: rgba(0,0,0,0.04); display:flex; align-items:center; justify-content:center; }
    .note-btn:hover { background: rgba(0,0,0,0.08); color: rgba(15,23,42,0.9); }
    .note-btn.has-notes { color: #0f172a; background: rgba(16, 185, 129, 0.18); }

    /* Resizable splitter */
    .splitter {
      width: 8px;
      cursor: col-resize;
      background: linear-gradient(to right, transparent, rgba(0,0,0,0.06), transparent);
    }
    .splitter:hover { background: linear-gradient(to right, transparent, rgba(79,70,229,0.25), transparent); }
    .splitter:active { background: linear-gradient(to right, transparent, rgba(79,70,229,0.35), transparent); }
    .splitter-header { width: 8px; }
    .no-select { user-select: none !important; }
    .col-resize { cursor: col-resize !important; }

    /* Color swatch + palette */
    .swatch { width: 14px; height: 14px; border-radius: 4px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18); }
    .swatch-btn { display:flex; align-items:center; justify-content:center; width: 22px; height: 22px; border-radius: 8px; }
    .swatch-btn:hover { background: rgba(0,0,0,0.04); }
    .palette { position:absolute; left: 34px; top: 50%; transform: translateY(-50%); background:#fff; border:1px solid rgba(0,0,0,0.08); border-radius: 12px; padding: 8px; box-shadow: 0 10px 24px rgba(0,0,0,0.12); z-index: 60; }
    .palette-grid { display:grid; grid-template-columns: repeat(8, 18px); gap: 8px; }
    .palette-dot { width: 18px; height: 18px; border-radius: 6px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18); cursor:pointer; }
    .palette-dot:hover { transform: translateY(-1px); }
    .palette-label { font-size: 11px; color: rgba(0,0,0,0.55); margin-bottom: 6px; user-select:none; }

    /* Left pane: keep Task name visible when narrowing */
    .task-row-grid { grid-template-columns: 20px 26px minmax(140px, 1fr) var(--col-dep) var(--col-start) var(--col-end) var(--col-dur) 28px; }

    body.left-hide-dur { --col-dur: 0px; }
    body.left-hide-end { --col-end: 0px; }
    body.left-hide-start { --col-start: 0px; }
    body.left-hide-dep { --col-dep: 0px; }

    body.left-hide-dur .col-dur,
    body.left-hide-end .col-end,
    body.left-hide-start .col-start,
    body.left-hide-dep .col-dep { display:none; }

    .task-name { min-width: 0; }
    .col-dep { min-width: 0; }
    .col-dep select { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="h-screen w-full flex flex-col py-4 px-4 md:px-6">
    <header class="mb-4">
      <div class="flex items-center justify-between gap-3">
        <div>
          <input id="projectTitle" class="w-full text-2xl md:text-3xl font-semibold tracking-tight bg-transparent outline-none" value="Project name" />
          <p class="text-sm text-gray-600">Interactive Gantt — reorder, drag, resize, add milestones, filter, delete. Persistent + shareable.</p>
        </div>
        <div class="flex flex-wrap items-center gap-2">
          <input id="search" type="search" placeholder="Filter…" class="h-10 px-3 rounded-xl border border-gray-300 bg-white shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500" />
          <button id="addTask" class="h-10 px-3 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700 shadow">+ Task</button>
          <button id="addMilestone" class="h-10 px-3 rounded-xl bg-purple-600 text-white hover:bg-purple-700 shadow">+ Milestone</button>
          <button id="undoBtn" class="h-10 px-3 rounded-xl bg-gray-200 hover:bg-gray-300 shadow">Undo</button>
          <button id="redoBtn" class="h-10 px-3 rounded-xl bg-gray-200 hover:bg-gray-300 shadow">Redo</button>
          <button id="share" class="h-10 px-3 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700 shadow">Share</button>
          <button id="notesBtn" class="h-10 px-3 rounded-xl bg-white text-gray-700 border border-gray-200 hover:bg-gray-50 shadow">Notes</button>
          <div class="flex items-center gap-1 bg-gray-100 rounded-xl p-1 shadow">
            <button type="button" class="zoom-btn px-2 py-1 text-xs font-medium rounded-lg text-gray-600" data-zoom="day">Day</button>
            <button type="button" class="zoom-btn px-2 py-1 text-xs font-medium rounded-lg text-gray-600" data-zoom="week">Week</button>
            <button type="button" class="zoom-btn px-2 py-1 text-xs font-medium rounded-lg text-gray-600" data-zoom="month">Month</button>
          </div>
          <button id="criticalToggle" class="h-10 px-3 rounded-xl bg-gray-200 text-gray-700 hover:bg-gray-300 shadow" aria-pressed="false">Critical Path</button>
          <button id="today" class="h-10 px-3 rounded-xl bg-rose-600 text-white hover:bg-rose-700 shadow">Today</button>
          <button id="centerToday" class="h-10 px-3 rounded-xl bg-rose-100 text-rose-700 hover:bg-rose-200 shadow">Center Today</button>
          <div class="relative">
            <button id="menuBtn" class="h-10 w-10 flex items-center justify-center rounded-xl bg-gray-200 hover:bg-gray-300 shadow" aria-label="Menu">⋮</button>
            <div id="menu" class="hidden absolute right-0 mt-2 w-48 rounded-xl bg-white shadow-lg ring-1 ring-black/5 z-50">
              <button id="loadSample" class="w-full text-left px-4 py-2 text-sm hover:bg-gray-100">Load sample project</button>
              <button id="importCsv" class="w-full text-left px-4 py-2 text-sm hover:bg-gray-100">Import CSV</button>
              <button id="exportCsv" class="w-full text-left px-4 py-2 text-sm hover:bg-gray-100">Export CSV</button>
              <button id="clearData" class="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50">Clear all data…</button>
            </div>
            <input id="importCsvInput" type="file" accept=".csv,text/csv" class="hidden" />
          </div>
        </div>
      </div>
      <div class="mt-2 text-xs text-gray-500 flex flex-wrap gap-x-4 gap-y-1">
        <div><span class="font-medium text-gray-600">Drag:</span> cursor-locked</div>
        <div><span class="font-medium text-gray-600">Link:</span> drag dot to connect</div>
        <div><span class="font-medium text-gray-600">Snap:</span> Shift = 5 days, Ctrl/Cmd = weeks</div>
        <div><span class="font-medium text-gray-600">Limit:</span> can’t plan earlier than today − 1 month</div>
      </div>
    </header>

    <div class="rounded-2xl bg-white shadow ring-1 ring-gray-200 overflow-hidden flex-1 flex flex-col min-h-0">
      <!-- Column headers -->
      <div id="headerGrid" class="grid" style="grid-template-columns: var(--left-w) 8px 1fr;">
        <div class="px-4 py-2 text-xs font-medium text-gray-600 border-b">
          <div class="grid items-center task-row-grid" style="gap: 8px;">
            <div></div>
            <div></div>
            <div>Task</div>
            <div class="text-left col-dep">Depends</div>
            <div class="text-right col-start">Start</div>
            <div class="text-right col-end">End</div>
            <div class="text-right col-dur">Dur</div>
            <div></div>
          </div>
        </div>
        <div class="splitter splitter-header border-b" aria-hidden="true"></div>
        <div class="px-4 py-2 text-xs font-medium text-gray-600 border-b">Timeline</div>
      </div>

      <div id="mainGrid" class="grid flex-1 min-h-0" style="grid-template-columns: var(--left-w) 8px 1fr;">
        <div id="leftPane" class="overflow-y-auto min-h-0">
          <div id="leftSpacer" class="sticky top-0 z-20 bg-white border-b" style="height: var(--scale-h);"></div>
          <ul id="taskList"></ul>
        </div>

        <div id="splitter" class="splitter" role="separator" aria-orientation="vertical" aria-label="Resize task panel"></div>

        <!-- Right: single scroll container for BOTH scale + chart (no syncing needed) -->
        <div id="rightPane" class="relative overflow-auto scrollbar-thin min-h-0">
          <div id="scaleSticky" class="sticky top-0 z-20 bg-white border-b">
            <div id="scale" class="text-xs text-gray-600 select-none"></div>
          </div>
          <div id="ganttGrid" class="relative min-w-max"></div>
        </div>
      </div>
    </div>

    <footer class="mt-3 text-xs text-gray-500">Data persists locally; use Share to download a portable HTML file you can email. All times are UTC-based for consistency.</footer>
  </div>

  <div id="drawerOverlay" class="hidden fixed inset-0 bg-black/30 z-40"></div>
  <aside id="drawer" class="fixed right-0 top-0 h-full w-full max-w-sm bg-white shadow-2xl border-l border-gray-200 transform translate-x-full transition-transform duration-200 z-50">
    <div class="h-full flex flex-col">
      <div class="px-4 py-3 border-b flex items-center justify-between">
        <div class="text-sm font-semibold text-gray-900" id="drawerTitle">Notes</div>
        <button id="drawerClose" class="text-xs font-semibold text-gray-500 hover:text-gray-700">Close</button>
      </div>
      <div class="p-4 space-y-4 overflow-y-auto">
        <div id="projectNotesSection" class="space-y-2">
          <div class="text-xs font-semibold text-gray-600">Project notes</div>
          <textarea id="projectNotesInput" class="w-full h-40 text-sm border border-gray-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Project context, goals, risks, decisions..."></textarea>
        </div>
        <div id="taskNotesSection" class="space-y-2 hidden">
          <div class="space-y-1">
            <div class="text-xs font-semibold text-gray-500 uppercase tracking-wide">Task</div>
            <div id="drawerTaskName" class="text-sm font-semibold text-gray-900"></div>
            <div id="drawerTaskDates" class="text-xs text-gray-500"></div>
          </div>
          <textarea id="taskNotesInput" class="w-full h-48 text-sm border border-gray-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Task notes, blockers, context..."></textarea>
        </div>
      </div>
    </div>
  </aside>

  <script id="embeddedData" type="application/json"></script>

<script>
(() => {
  const DAY_MS = 24*60*60*1000;
  const ROW_H = 38;
  const DEFAULT_DAY_W = 24;
  let dayW = DEFAULT_DAY_W;
  const ZOOM_LEVELS = {
    day: { label: 'Day', dayW: 24 },
    week: { label: 'Week', dayW: 14 },
    month: { label: 'Month', dayW: 8 },
  };
  let zoomKey = 'day';
  const SCALE_H = 44; // fallback; actual scale height is measured from DOM for perfect alignment
  const STORAGE_KEY = 'bdc-fre-gantt-v1';
  const META_KEY = 'bdc-fre-gantt-meta-v1';
  const UI_KEY = 'bdc-fre-gantt-ui-v1';
  const EMBEDDED_DATA_ID = 'embeddedData';

  /** @typedef {{id:string,name:string,start:string,end?:string,milestone?:boolean,color?:string,dependsOnId?:string,notes?:string}} Task */
  /** @type {Task[]} */
  let tasks = [];
  let filteredIds = new Set();
  let showCriticalPath = false;
  let projectNotes = '';

  let dragCtx = null;
  let linkCtx = null;
  const drawerState = { open: false, mode: 'project', taskId: null };

  const els = {
    projectTitle: document.getElementById('projectTitle'),
    search: document.getElementById('search'),
    addTask: document.getElementById('addTask'),
    addMilestone: document.getElementById('addMilestone'),
    undoBtn: document.getElementById('undoBtn'),
    redoBtn: document.getElementById('redoBtn'),
    share: document.getElementById('share'),
    notesBtn: document.getElementById('notesBtn'),
    criticalToggle: document.getElementById('criticalToggle'),
    scale: document.getElementById('scale'),
    left: document.getElementById('taskList'),
    grid: document.getElementById('ganttGrid'),
    rightPane: document.getElementById('rightPane'),
    todayBtn: document.getElementById('today'),
    centerTodayBtn: document.getElementById('centerToday'),
    menuBtn: document.getElementById('menuBtn'),
    menu: document.getElementById('menu'),
    clearData: document.getElementById('clearData'),
    loadSample: document.getElementById('loadSample'),
    importCsv: document.getElementById('importCsv'),
    importCsvInput: document.getElementById('importCsvInput'),
    exportCsv: document.getElementById('exportCsv'),
    splitter: document.getElementById('splitter'),
    drawer: document.getElementById('drawer'),
    drawerOverlay: document.getElementById('drawerOverlay'),
    drawerTitle: document.getElementById('drawerTitle'),
    drawerClose: document.getElementById('drawerClose'),
    projectNotesInput: document.getElementById('projectNotesInput'),
    taskNotesInput: document.getElementById('taskNotesInput'),
    projectNotesSection: document.getElementById('projectNotesSection'),
    taskNotesSection: document.getElementById('taskNotesSection'),
    drawerTaskName: document.getElementById('drawerTaskName'),
    drawerTaskDates: document.getElementById('drawerTaskDates'),
  };
  const zoomButtons = Array.from(document.querySelectorAll('.zoom-btn'));

  const uid = () => Math.random().toString(36).slice(2, 10);
  const toDate = (iso) => new Date(iso + 'T00:00:00Z');
  const toDateSafe = (iso) => {
    if (typeof iso !== 'string') return null;
    const d = new Date(iso + 'T00:00:00Z');
    return Number.isNaN(d.getTime()) ? null : d;
  };
  const toISO = (d) => d.toISOString().slice(0,10);
  const addDays = (d, n) => new Date(d.getTime() + n*DAY_MS);
  const addMonthsUTC = (d, months) => {
    // Preserve UTC day as much as possible; JS will roll overflow days into next month.
    return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + months, d.getUTCDate()));
  };
  const daysBetween = (a,b) => Math.round((b - a)/DAY_MS);
  const fmtMon = (d) => d.toLocaleString('en-GB',{month:'short', timeZone:'UTC'});
  const fmtDay = (d) => d.getUTCDate();
  const startOfDayUTC = (d) => new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
  const todayUTC = () => startOfDayUTC(new Date());
  const isWeekend = (d) => [0,6].includes(d.getUTCDay());
  const isBusinessDay = (d) => !isWeekend(d);

  // Business day rules (Model B)
  // - Start dates: never on weekend; if they land on weekend, snap forward to Monday.
  // - End dates: never on weekend; if they land on weekend, snap back to Friday.
  function snapStartToBusinessDay(d) {
    const dd = startOfDayUTC(d);
    if (!isWeekend(dd)) return dd;
    // Sat -> +2, Sun -> +1
    const dow = dd.getUTCDay();
    return addDays(dd, dow === 6 ? 2 : 1);
  }
  function snapEndToBusinessDay(d) {
    const dd = startOfDayUTC(d);
    if (!isWeekend(dd)) return dd;
    // Sat -> -1, Sun -> -2
    const dow = dd.getUTCDay();
    return addDays(dd, dow === 6 ? -1 : -2);
  }

  // Add N business days (can be negative). N=0 returns the same business day (snapped to business day).
  function addBusinessDays(date, n) {
    let d = startOfDayUTC(date);
    // For increments, always operate on business days.
    d = n >= 0 ? snapStartToBusinessDay(d) : snapEndToBusinessDay(d);
    if (n === 0) return d;
    const step = n > 0 ? 1 : -1;
    let remaining = Math.abs(n);
    while (remaining > 0) {
      d = addDays(d, step);
      if (isBusinessDay(d)) remaining--;
    }
    return d;
  }

  // Inclusive business-day count from start..end (both should be business days)
  function businessDaysInclusive(start, end) {
    const s = startOfDayUTC(start);
    const e = startOfDayUTC(end);
    if (e < s) return 0;
    let d = s;
    let count = 0;
    while (d <= e) {
      if (isBusinessDay(d)) count++;
      d = addDays(d, 1);
    }
    return count;
  }

  const minLimitDate = () => addDays(todayUTC(), -31);

  // Colors
  const PALETTE = [
    '#4f46e5', // indigo
    '#0ea5e9', // sky
    '#14b8a6', // teal
    '#10b981', // emerald
    '#84cc16', // lime
    '#f59e0b', // amber
    '#f97316', // orange
    '#ef4444', // red
    '#ec4899', // pink
    '#a855f7', // purple
    '#64748b', // slate
    '#0f172a', // near-black
  ];
  const DEFAULT_TASK_COLOR = '#4f46e5';
  const DEFAULT_MILESTONE_COLOR = '#9333ea';
  const DEP_LINE_COLOR = '#94a3b8';
  const LINK_LINE_COLOR = '#f59e0b';

  function escapeHtml(s) {
    return String(s)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function hexToRgb(hex) {
    const h = String(hex || '').trim();
    const m = h.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
    if (!m) return null;
    let v = m[1];
    if (v.length === 3) v = v.split('').map(ch => ch + ch).join('');
    const n = parseInt(v, 16);
    return { r: (n>>16)&255, g: (n>>8)&255, b: n&255 };
  }
  function textColorForBg(hex) {
    const rgb = hexToRgb(hex);
    if (!rgb) return '#ffffff';
    const srgb = [rgb.r, rgb.g, rgb.b].map(v => {
      const c = v/255;
      return c <= 0.03928 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4);
    });
    const L = 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
    return L > 0.52 ? '#0f172a' : '#ffffff';
  }

  function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks)); }
  function saveMeta(meta) {
    const prev = loadMeta() || {};
    localStorage.setItem(META_KEY, JSON.stringify({ ...prev, ...meta }));
  }
  function loadMeta() {
    const raw = localStorage.getItem(META_KEY);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }
  function saveUI(ui) {
    const prev = loadUI() || {};
    localStorage.setItem(UI_KEY, JSON.stringify({ ...prev, ...ui }));
  }
  function loadUI() {
    const raw = localStorage.getItem(UI_KEY);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  const historyState = { stack: [], index: -1 };
  const HISTORY_LIMIT = 80;
  let historyLocked = false;

  function cloneTasksSnapshot() {
    if (typeof structuredClone === 'function') return structuredClone(tasks);
    return JSON.parse(JSON.stringify(tasks));
  }

  function snapshotState() {
    const title = els.projectTitle ? els.projectTitle.value.trim() || 'Project name' : 'Project name';
    return { tasks: cloneTasksSnapshot(), title, notes: projectNotes };
  }

  function applySnapshot(snapshot) {
    tasks = snapshot.tasks || [];
    projectNotes = snapshot.notes || '';
    if (els.projectTitle) {
      els.projectTitle.value = snapshot.title || 'Project name';
      document.title = (snapshot.title || 'Project name') + ' — Gantt';
      saveMeta({ title: snapshot.title || 'Project name', notes: projectNotes });
    }
    save();
    render();
    updateDrawerContent();
  }

  function updateHistoryButtons() {
    if (!els.undoBtn || !els.redoBtn) return;
    const canUndo = historyState.index > 0;
    const canRedo = historyState.index < historyState.stack.length - 1;
    els.undoBtn.disabled = !canUndo;
    els.redoBtn.disabled = !canRedo;
    els.undoBtn.classList.toggle('opacity-50', !canUndo);
    els.undoBtn.classList.toggle('cursor-not-allowed', !canUndo);
    els.redoBtn.classList.toggle('opacity-50', !canRedo);
    els.redoBtn.classList.toggle('cursor-not-allowed', !canRedo);
  }

  function commitHistory() {
    if (historyLocked) return;
    const snap = snapshotState();
    if (historyState.index < historyState.stack.length - 1) {
      historyState.stack = historyState.stack.slice(0, historyState.index + 1);
    }
    historyState.stack.push(snap);
    if (historyState.stack.length > HISTORY_LIMIT) {
      historyState.stack.shift();
    }
    historyState.index = historyState.stack.length - 1;
    updateHistoryButtons();
  }

  function undo() {
    if (historyState.index <= 0) return;
    historyLocked = true;
    historyState.index--;
    applySnapshot(historyState.stack[historyState.index]);
    historyLocked = false;
    updateHistoryButtons();
  }

  function redo() {
    if (historyState.index >= historyState.stack.length - 1) return;
    historyLocked = true;
    historyState.index++;
    applySnapshot(historyState.stack[historyState.index]);
    historyLocked = false;
    updateHistoryButtons();
  }

  function clampLeftWidth(px) {
    const min = 420;
    const max = Math.max(min + 240, Math.floor(window.innerWidth * 0.75));
    return Math.max(min, Math.min(max, px));
  }

  function applyLeftLayout(w) {
    document.body.classList.remove('left-hide-dur','left-hide-end','left-hide-start','left-hide-dep');
    if (w < 520) {
      document.body.classList.add('left-hide-start','left-hide-end','left-hide-dur','left-hide-dep');
    } else if (w < 600) {
      document.body.classList.add('left-hide-start','left-hide-end','left-hide-dur');
    } else if (w < 680) {
      document.body.classList.add('left-hide-end','left-hide-dur');
    } else if (w < 760) {
      document.body.classList.add('left-hide-dur');
    }
  }

  function updateZoomButtons() {
    zoomButtons.forEach(btn => {
      const active = btn.dataset.zoom === zoomKey;
      btn.classList.toggle('bg-white', active);
      btn.classList.toggle('text-gray-900', active);
      btn.classList.toggle('shadow', active);
      btn.classList.toggle('text-gray-600', !active);
    });
  }

  function updateCriticalToggle() {
    if (!els.criticalToggle) return;
    const active = showCriticalPath;
    els.criticalToggle.setAttribute('aria-pressed', active ? 'true' : 'false');
    els.criticalToggle.classList.toggle('bg-rose-100', active);
    els.criticalToggle.classList.toggle('text-rose-700', active);
    els.criticalToggle.classList.toggle('hover:bg-rose-200', active);
    els.criticalToggle.classList.toggle('bg-gray-200', !active);
    els.criticalToggle.classList.toggle('text-gray-700', !active);
    els.criticalToggle.classList.toggle('hover:bg-gray-300', !active);
  }

  function setZoom(key, persist=false) {
    if (!ZOOM_LEVELS[key]) return;
    zoomKey = key;
    dayW = ZOOM_LEVELS[key].dayW;
    updateZoomButtons();
    if (persist) saveUI({ zoom: zoomKey });
    render();
  }

  function setLeftWidth(px, persist=false) {
    const w = clampLeftWidth(px);
    document.documentElement.style.setProperty('--left-w', w + 'px');
    applyLeftLayout(w);
    if (persist) saveUI({ leftW: w });
  }

  function normalizeTasks() {
    // Ensure all tasks comply with business-day rules.
    if (!Array.isArray(tasks)) {
      tasks = [];
      return;
    }
    tasks = tasks
      .filter(t => t && typeof t === 'object')
      .map(t => {
      const out = { ...t };
      if (typeof out.id !== 'string' || !out.id) out.id = uid();
      if (typeof out.name !== 'string') out.name = 'Untitled task';
      if (out.dependsOnId && typeof out.dependsOnId !== 'string') delete out.dependsOnId;
      if (out.notes != null && typeof out.notes !== 'string') out.notes = String(out.notes);
      const startRaw = toDateSafe(out.start);
      const endRaw = toDateSafe(out.end);
      const baseStart = startRaw || endRaw || todayUTC();
      const s = snapStartToBusinessDay(baseStart);
      out.start = toISO(s);
      if (out.milestone) {
        delete out.end;
        return out;
      }
      const e0 = endRaw || startRaw || s;
      let e = snapEndToBusinessDay(e0);
      if (e < s) e = s;
      out.end = toISO(e);
      return out;
    });
  }

  function getTaskById(id) {
    return tasks.find(t => t.id === id);
  }

  function getTaskEndDate(t) {
    const s = toDate(t.start);
    return t.milestone ? s : toDate(t.end || t.start);
  }

  function pruneDependencies() {
    const ids = new Set(tasks.map(t => t.id));
    tasks.forEach(t => {
      if (!t.dependsOnId) {
        delete t.dependsOnId;
        return;
      }
      if (!ids.has(t.dependsOnId) || t.dependsOnId === t.id) delete t.dependsOnId;
    });
  }

  function applyDependencies() {
    pruneDependencies();
    const visiting = new Set();
    const visited = new Set();

    function enforce(t) {
      if (visited.has(t.id)) return;
      if (!t.dependsOnId) {
        visited.add(t.id);
        return;
      }
      if (visiting.has(t.id)) return;
      const pred = getTaskById(t.dependsOnId);
      if (!pred) {
        delete t.dependsOnId;
        visited.add(t.id);
        return;
      }
      visiting.add(t.id);
      enforce(pred);
      visiting.delete(t.id);

      const predEnd = getTaskEndDate(pred);
      const minStart = addBusinessDays(predEnd, 1);
      const curStart = toDate(t.start);
      if (curStart < minStart) {
        if (t.milestone) {
          t.start = toISO(minStart);
        } else {
          const curEnd = toDate(t.end || t.start);
          const durBiz = Math.max(1, businessDaysInclusive(curStart, curEnd));
          t.start = toISO(minStart);
          t.end = toISO(addBusinessDays(minStart, durBiz - 1));
        }
      }
      visited.add(t.id);
    }

    tasks.forEach(enforce);
  }

  function computeDependencyWarnings(taskIndexById) {
    const warnings = new Map();
    const byId = new Map(tasks.map(t => [t.id, t]));
    const state = new Map();

    function markCycle(stack, startId) {
      const startIdx = stack.indexOf(startId);
      if (startIdx === -1) return;
      stack.slice(startIdx).forEach(id => {
        warnings.set(id, 'Dependency cycle');
      });
    }

    function dfs(t, stack) {
      const st = state.get(t.id);
      if (st === 'visiting') {
        markCycle(stack, t.id);
        return;
      }
      if (st === 'done') return;
      state.set(t.id, 'visiting');
      stack.push(t.id);
      if (t.dependsOnId) {
        const pred = byId.get(t.dependsOnId);
        if (pred) dfs(pred, stack);
      }
      stack.pop();
      state.set(t.id, 'done');
    }

    tasks.forEach(t => dfs(t, []));
    tasks.forEach(t => {
      if (!t.dependsOnId) return;
      const pred = byId.get(t.dependsOnId);
      if (!pred) warnings.set(t.id, 'Missing dependency');
      const predIdx = taskIndexById.get(t.dependsOnId);
      const curIdx = taskIndexById.get(t.id);
      if (predIdx !== undefined && curIdx !== undefined && predIdx > curIdx) {
        warnings.set(t.id, 'Dependency is after this task');
      }
    });

    return warnings;
  }

  function taskDurationBiz(t) {
    if (t.milestone) return 0;
    const s = toDate(t.start);
    const e = toDate(t.end || t.start);
    return Math.max(1, businessDaysInclusive(s, e));
  }

  function computeCriticalPathIds() {
    const byId = new Map(tasks.map(t => [t.id, t]));
    const memo = new Map();
    const visiting = new Set();

    function dfs(id) {
      if (memo.has(id)) return memo.get(id);
      const t = byId.get(id);
      if (!t) return { len: 0, pred: null };
      if (visiting.has(id)) {
        const info = { len: taskDurationBiz(t), pred: null };
        memo.set(id, info);
        return info;
      }
      visiting.add(id);
      let pred = null;
      let len = taskDurationBiz(t);
      if (t.dependsOnId && byId.has(t.dependsOnId)) {
        const prev = dfs(t.dependsOnId);
        pred = t.dependsOnId;
        len = prev.len + taskDurationBiz(t);
      }
      visiting.delete(id);
      const info = { len, pred };
      memo.set(id, info);
      return info;
    }

    let maxId = null;
    let maxLen = -1;
    tasks.forEach(t => {
      const info = dfs(t.id);
      if (info.len > maxLen) {
        maxLen = info.len;
        maxId = t.id;
      }
    });

    const critical = new Set();
    let cur = maxId;
    const seen = new Set();
    while (cur && !seen.has(cur)) {
      critical.add(cur);
      seen.add(cur);
      const info = memo.get(cur);
      cur = info ? info.pred : null;
    }
    return critical;
  }

  function loadEmbeddedPayload() {
    const el = document.getElementById(EMBEDDED_DATA_ID);
    if (!el) return null;
    const raw = el.textContent.trim();
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  function applyEmbeddedPayload(raw) {
    const payload = Array.isArray(raw) ? { tasks: raw } : raw;
    if (!payload || !Array.isArray(payload.tasks)) return false;
    tasks = payload.tasks;
    normalizeTasks();
    applyDependencies();
    const embeddedTitle = payload.meta && typeof payload.meta.title === 'string'
      ? payload.meta.title.trim()
      : '';
    const embeddedNotes = payload.meta && typeof payload.meta.notes === 'string'
      ? payload.meta.notes
      : '';
    if (embeddedTitle && els.projectTitle) {
      els.projectTitle.value = embeddedTitle;
      document.title = embeddedTitle + ' — Gantt';
    }
    projectNotes = embeddedNotes;
    if (embeddedTitle || embeddedNotes) {
      saveMeta({ title: embeddedTitle || (els.projectTitle ? els.projectTitle.value.trim() : 'Project name'), notes: projectNotes });
    }
    save();
    return true;
  }

  function slugifyFileName(name) {
    return String(name || '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '') || 'gantt-project';
  }

  function buildPortableHtml(payload) {
    const json = JSON.stringify(payload).replace(/</g, '\\u003c');
    const cloned = document.documentElement.cloneNode(true);
    const embedded = cloned.querySelector('#' + EMBEDDED_DATA_ID);
    if (!embedded) return null;
    embedded.textContent = json;
    return '<!DOCTYPE html>\n' + cloned.outerHTML;
  }

  function formatTaskDates(t) {
    if (!t) return '';
    if (t.milestone) return `Milestone - ${t.start}`;
    const end = t.end || t.start;
    return `${t.start} -> ${end}`;
  }

  function updateDrawerContent() {
    if (!els.drawer) return;
    if (drawerState.mode === 'project') {
      if (els.projectNotesSection) els.projectNotesSection.classList.remove('hidden');
      if (els.taskNotesSection) els.taskNotesSection.classList.add('hidden');
      if (els.drawerTitle) els.drawerTitle.textContent = 'Project Notes';
      if (els.projectNotesInput) els.projectNotesInput.value = projectNotes || '';
      return;
    }

    const t = getTaskById(drawerState.taskId);
    if (!t) {
      closeDrawer();
      return;
    }
    if (els.projectNotesSection) els.projectNotesSection.classList.add('hidden');
    if (els.taskNotesSection) els.taskNotesSection.classList.remove('hidden');
    if (els.drawerTitle) els.drawerTitle.textContent = 'Task Notes';
    if (els.drawerTaskName) els.drawerTaskName.textContent = t.name || 'Untitled task';
    if (els.drawerTaskDates) els.drawerTaskDates.textContent = formatTaskDates(t);
    if (els.taskNotesInput) els.taskNotesInput.value = t.notes || '';
  }

  function updateDrawerTaskMeta(t) {
    if (!drawerState.open || drawerState.mode !== 'task' || drawerState.taskId !== t.id) return;
    if (els.drawerTaskName) els.drawerTaskName.textContent = t.name || 'Untitled task';
    if (els.drawerTaskDates) els.drawerTaskDates.textContent = formatTaskDates(t);
  }

  function openDrawer(mode, taskId) {
    drawerState.open = true;
    drawerState.mode = mode;
    drawerState.taskId = taskId || null;
    updateDrawerContent();
    if (els.drawerOverlay) els.drawerOverlay.classList.remove('hidden');
    if (els.drawer) {
      els.drawer.classList.remove('translate-x-full');
      els.drawer.classList.add('translate-x-0');
    }
    requestAnimationFrame(() => {
      const focusEl = mode === 'project' ? els.projectNotesInput : els.taskNotesInput;
      if (focusEl) focusEl.focus();
    });
  }

  function closeDrawer() {
    drawerState.open = false;
    drawerState.taskId = null;
    if (els.drawerOverlay) els.drawerOverlay.classList.add('hidden');
    if (els.drawer) {
      els.drawer.classList.add('translate-x-full');
      els.drawer.classList.remove('translate-x-0');
    }
  }

  function updateTaskNoteBadge(taskId) {
    const li = document.querySelector(`#taskList li[data-task-id="${taskId}"]`);
    if (!li) return;
    const btn = li.querySelector('.note-btn');
    if (!btn) return;
    const t = getTaskById(taskId);
    const hasNotes = t && typeof t.notes === 'string' && t.notes.trim().length > 0;
    btn.classList.toggle('has-notes', hasNotes);
  }

  function updateDependencyLabels(t) {
    const label = (t.name || '').trim() || 'Untitled task';
    document.querySelectorAll(`select[data-deps] option[value="${t.id}"]`).forEach(opt => {
      opt.textContent = label;
    });
  }

  function updateTaskNameInGantt(t) {
    if (!els.grid) return;
    const el = els.grid.querySelector(`[data-id="${t.id}"]`);
    if (!el) return;
    if (t.milestone) {
      el.title = `${t.name} — ${t.start}`;
      return;
    }
    const end = t.end || t.start;
    el.title = `${t.name} — ${t.start} → ${end}`;
    const label = el.querySelector('.bar-label');
    if (label) label.textContent = t.name;
  }

  function applyStartInput(t, value) {
    const d = toDateSafe(value);
    if (!d) return false;
    const s = clampStartToLimit(d);
    const newStartISO = toISO(s);
    if (t.milestone) {
      if (t.start === newStartISO) return false;
      t.start = newStartISO;
      return true;
    }
    const curStart = toDateSafe(t.start) || s;
    const curEnd = toDateSafe(t.end) || curStart;
    const durBiz = Math.max(1, businessDaysInclusive(curStart, curEnd));
    const newEndISO = toISO(addBusinessDays(s, durBiz - 1));
    if (t.start === newStartISO && t.end === newEndISO) return false;
    t.start = newStartISO;
    t.end = newEndISO;
    return true;
  }

  function applyEndInput(t, value) {
    if (t.milestone) return false;
    const d = toDateSafe(value);
    if (!d) return false;
    let e = snapEndToBusinessDay(d);
    const s = toDateSafe(t.start) || e;
    if (e < s) e = s;
    const newEndISO = toISO(e);
    if (t.end === newEndISO) return false;
    t.end = newEndISO;
    return true;
  }

  function sampleTasks() {
    const base = snapStartToBusinessDay(todayUTC());
    const t1 = { id: uid(), name: 'Project Kickoff', start: toISO(base), end: toISO(addBusinessDays(base, 5-1)), color: '#4f46e5' };
    const t2 = { id: uid(), name: 'Data Model Draft', start: toISO(addBusinessDays(base, 2)), end: toISO(addBusinessDays(addBusinessDays(base, 2), 10-1)), color: '#0ea5e9', dependsOnId: t1.id };
    const t3 = { id: uid(), name: 'Milestone: Exec Checkpoint', start: toISO(addBusinessDays(base, 8)), milestone:true, color: '#9333ea', dependsOnId: t2.id };
    const t4 = { id: uid(), name: 'PoC Build', start: toISO(addBusinessDays(base, 10)), end: toISO(addBusinessDays(addBusinessDays(base, 10), 12-1)), color: '#10b981', dependsOnId: t3.id };
    return [t1, t2, t3, t4];
  }

  function clearShareHash() {
    if (!location.hash) return;
    history.replaceState(null, '', location.pathname + location.search);
  }

  function resetSearch() {
    if (els.search) els.search.value = '';
  }

  function load() {
    if (applyEmbeddedPayload(loadEmbeddedPayload())) return;

    const meta = loadMeta();
    if (meta && meta.title && els.projectTitle) {
      els.projectTitle.value = meta.title;
      document.title = meta.title + ' — Gantt';
    }
    projectNotes = meta && typeof meta.notes === 'string' ? meta.notes : '';

    // Local storage
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      try {
        tasks = JSON.parse(raw);
        normalizeTasks();
        applyDependencies();
        save();
        return;
      } catch (e) {
        console.warn('Failed to parse local data', e);
      }
    }

    // Defaults
    tasks = sampleTasks();
    applyDependencies();
    save();
  }

  function sharePortable() {
    const title = els.projectTitle ? els.projectTitle.value.trim() : '';
    const payload = {
      tasks,
      meta: { title: title || 'Project name', notes: projectNotes || '' },
    };
    const html = buildPortableHtml(payload);
    if (!html) {
      alert('Unable to create a share file in this browser.');
      return;
    }
    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const stamp = toISO(todayUTC());
    const base = slugifyFileName(title || 'gantt-project');
    a.href = url;
    a.download = `${base}-${stamp}.html`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function csvEscape(value) {
    const s = String(value ?? '');
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }

  function normalizeHeaderKey(key) {
    return String(key || '').trim().toLowerCase().replace(/[^a-z0-9]/g, '');
  }

  function parseCsv(text) {
    const rows = [];
    let row = [];
    let field = '';
    let inQuotes = false;
    const s = String(text || '');
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (inQuotes) {
        if (ch === '"') {
          if (s[i + 1] === '"') {
            field += '"';
            i++;
          } else {
            inQuotes = false;
          }
        } else {
          field += ch;
        }
        continue;
      }
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === ',') {
        row.push(field);
        field = '';
      } else if (ch === '\n') {
        row.push(field);
        rows.push(row);
        row = [];
        field = '';
      } else if (ch === '\r') {
        row.push(field);
        rows.push(row);
        row = [];
        field = '';
        if (s[i + 1] === '\n') i++;
      } else {
        field += ch;
      }
    }
    row.push(field);
    rows.push(row);
    while (rows.length && rows[rows.length - 1].every(cell => String(cell) === '')) {
      rows.pop();
    }
    return rows;
  }

  function importCsv(text) {
    const rows = parseCsv(text);
    if (!rows.length) {
      alert('CSV is empty.');
      return;
    }
    const headerRow = rows[0].map(normalizeHeaderKey);
    const hasHeader = headerRow.includes('name') && headerRow.includes('start');
    let map = null;
    let startIdx = 0;
    if (hasHeader) {
      const findIndex = (key) => headerRow.indexOf(key);
      const notesIndex = (() => {
        const idx = findIndex('notes');
        return idx !== -1 ? idx : findIndex('tasknotes');
      })();
      map = {
        id: findIndex('id'),
        name: findIndex('name'),
        start: findIndex('start'),
        end: findIndex('end'),
        milestone: findIndex('milestone'),
        dependsOnId: findIndex('dependsonid'),
        color: findIndex('color'),
        projectTitle: findIndex('projecttitle'),
        notes: notesIndex,
        projectNotes: findIndex('projectnotes'),
      };
      startIdx = 1;
    } else {
      map = { id: 0, name: 1, start: 2, end: 3, milestone: 4, dependsOnId: 5, color: 6, projectTitle: 7, notes: 8, projectNotes: 9 };
    }

    const imported = [];
    let importedTitle = '';
    let importedProjectNotes = '';
    for (let i = startIdx; i < rows.length; i++) {
      const row = rows[i];
      if (!row || row.every(cell => String(cell || '').trim() === '')) continue;
      const val = (key) => {
        const idx = map[key];
        if (idx === undefined || idx < 0) return '';
        return row[idx] ?? '';
      };
      const idRaw = String(val('id')).trim();
      const nameRaw = String(val('name')).trim();
      const startRaw = String(val('start')).trim();
      const endRaw = String(val('end')).trim();
      const milestoneRaw = String(val('milestone')).trim().toLowerCase();
      const dependsRaw = String(val('dependsOnId')).trim();
      const colorRaw = String(val('color')).trim();
      const titleRaw = String(val('projectTitle')).trim();
      const notesRaw = String(val('notes')).trim();
      const projectNotesRaw = String(val('projectNotes')).trim();
      const isMilestone = milestoneRaw === 'true' || milestoneRaw === '1' || milestoneRaw === 'yes';

      const task = {
        id: idRaw || uid(),
        name: nameRaw || 'Untitled task',
        start: startRaw,
      };
      if (notesRaw) task.notes = notesRaw;
      if (isMilestone) {
        task.milestone = true;
      } else if (endRaw) {
        task.end = endRaw;
      }
      if (dependsRaw) task.dependsOnId = dependsRaw;
      if (colorRaw) task.color = colorRaw;
      imported.push(task);
      if (!importedTitle && titleRaw) importedTitle = titleRaw;
      if (!importedProjectNotes && projectNotesRaw) importedProjectNotes = projectNotesRaw;
    }

    if (!imported.length) {
      alert('No tasks found in CSV.');
      return;
    }
    if (!confirm('Importing CSV will overwrite the current project. Continue?')) return;

    const title = importedTitle || 'Project name';
    projectNotes = importedProjectNotes || '';
    if (els.projectTitle) {
      els.projectTitle.value = title;
      document.title = title + ' — Gantt';
      saveMeta({ title, notes: projectNotes });
    }
    if (els.projectNotesInput) els.projectNotesInput.value = projectNotes || '';
    resetSearch();
    tasks = imported;
    normalizeTasks();
    applyDependencies();
    save();
    render();
    updateDrawerContent();
    commitHistory();
  }

  function exportCsv() {
    const title = els.projectTitle ? els.projectTitle.value.trim() : '';
    const titleValue = title || 'Project name';
    const header = ['id','name','start','end','milestone','dependsOnId','color','projectTitle','notes','projectNotes'];
    const rows = [header];
    tasks.forEach(t => {
      rows.push([
        t.id,
        t.name,
        t.start,
        t.milestone ? '' : (t.end || t.start),
        t.milestone ? 'true' : 'false',
        t.dependsOnId || '',
        t.color || '',
        titleValue,
        t.notes || '',
        projectNotes || '',
      ]);
    });
    const csv = rows.map(row => row.map(csvEscape).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const stamp = toISO(todayUTC());
    const base = slugifyFileName(title || 'gantt-project');
    a.href = url;
    a.download = `${base}-${stamp}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function bounds() {
    let minD = new Date('2999-01-01T00:00:00Z');
    let maxD = new Date('1970-01-01T00:00:00Z');
    for (const t of tasks) {
      const s = toDate(t.start);
      const e = t.milestone ? s : toDate(t.end || t.start);
      if (s < minD) minD = s;
      if (e > maxD) maxD = e;
    }

    const limit = minLimitDate();
    if (addDays(limit, -7) < minD) minD = addDays(limit, -7);
    minD = addDays(minD, -7);

    const minForwardMax = addMonthsUTC(todayUTC(), 12);
    if (minForwardMax > maxD) maxD = minForwardMax;

    maxD = addDays(maxD, 14);

    return {minD, maxD};
  }

  function scrollToDate(date, align='left') {
    const {minD} = bounds();
    const x = daysBetween(minD, date) * dayW;
    const pane = els.rightPane;
    pane.scrollLeft = Math.max(0, align === 'center' ? x - pane.clientWidth/2 : x);
  }

  function clampStartToLimit(date) {
    const minStart = snapStartToBusinessDay(minLimitDate());
    const d = startOfDayUTC(date);
    return snapStartToBusinessDay(d < minStart ? minStart : d);
  }

  function getScaleH() {
    const el = document.getElementById('scaleSticky');
    const h = el ? el.offsetHeight : 0;
    return h > 0 ? h : SCALE_H;
  }

  function renderDependencies(minD, totalH, gridWidth, rowIndexById, visibleIds) {
    const depTasks = tasks.filter(t => t.dependsOnId && visibleIds.has(t.id));
    if (depTasks.length === 0) return null;

    const ns = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(ns, 'svg');
    svg.setAttribute('width', gridWidth);
    svg.setAttribute('height', totalH);
    svg.classList.add('absolute');
    svg.style.left = '0px';
    svg.style.top = '0px';
    svg.style.pointerEvents = 'none';
    svg.setAttribute('aria-hidden', 'true');

    const defs = document.createElementNS(ns, 'defs');
    const marker = document.createElementNS(ns, 'marker');
    marker.setAttribute('id', 'dep-arrow');
    marker.setAttribute('viewBox', '0 0 6 6');
    marker.setAttribute('refX', '6');
    marker.setAttribute('refY', '3');
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.setAttribute('orient', 'auto');
    const arrowPath = document.createElementNS(ns, 'path');
    arrowPath.setAttribute('d', 'M0,0 L6,3 L0,6 Z');
    arrowPath.setAttribute('fill', DEP_LINE_COLOR);
    marker.appendChild(arrowPath);
    defs.appendChild(marker);
    svg.appendChild(defs);

    let hasLines = false;
    depTasks.forEach(t => {
      const pred = getTaskById(t.dependsOnId);
      if (!pred || !visibleIds.has(pred.id)) return;
      const predIdx = rowIndexById.get(pred.id);
      const depIdx = rowIndexById.get(t.id);
      if (predIdx === undefined || depIdx === undefined) return;

      const predEnd = getTaskEndDate(pred);
      let predX = daysBetween(minD, predEnd) * dayW;
      if (!pred.milestone) predX += dayW;

      const depStart = toDate(t.start);
      const depX = daysBetween(minD, depStart) * dayW;

      const startX = predX + (pred.milestone ? 8 : 2);
      let endX = depX - 6;

      const predY = predIdx * ROW_H + (ROW_H / 2);
      const depY = depIdx * ROW_H + (ROW_H / 2);
      let elbowX;
      if (endX <= startX + 4) {
        elbowX = startX + 12;
        endX = depX + 6;
      } else {
        elbowX = Math.max(startX + 8, Math.min(startX + 24, endX - 8));
      }

      const path = document.createElementNS(ns, 'path');
      path.setAttribute('d', `M ${startX} ${predY} L ${elbowX} ${predY} L ${elbowX} ${depY} L ${endX} ${depY}`);
      path.setAttribute('stroke', DEP_LINE_COLOR);
      path.setAttribute('stroke-width', '1.5');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', 'url(#dep-arrow)');
      svg.appendChild(path);

      const dot = document.createElementNS(ns, 'circle');
      dot.setAttribute('cx', String(startX));
      dot.setAttribute('cy', String(predY));
      dot.setAttribute('r', '2');
      dot.setAttribute('fill', DEP_LINE_COLOR);
      svg.appendChild(dot);

      hasLines = true;
    });

    return hasLines ? svg : null;
  }

  function highlightLinkTarget(targetId) {
    document.querySelectorAll('#taskList li.link-target').forEach(el => el.classList.remove('link-target'));
    if (!targetId) return;
    const li = document.querySelector(`#taskList li[data-task-id="${targetId}"]`);
    if (li) li.classList.add('link-target');
  }

  function wouldCreateCycle(predId, taskId) {
    let cur = predId;
    while (cur) {
      if (cur === taskId) return true;
      const t = getTaskById(cur);
      cur = t && t.dependsOnId ? t.dependsOnId : null;
    }
    return false;
  }

  function startLinkDrag(ev, sourceId, originEl) {
    ev.preventDefault();
    ev.stopPropagation();
    if (linkCtx) return;
    if (!els.grid) return;

    const gridRect = els.grid.getBoundingClientRect();
    const originRect = originEl.getBoundingClientRect();
    const startX = originRect.left - gridRect.left + (originRect.width / 2);
    const startY = originRect.top - gridRect.top + (originRect.height / 2);

    const ns = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(ns, 'svg');
    svg.setAttribute('width', String(els.grid.offsetWidth));
    svg.setAttribute('height', String(els.grid.offsetHeight));
    svg.classList.add('absolute');
    svg.style.left = '0px';
    svg.style.top = '0px';
    svg.style.pointerEvents = 'none';

    const line = document.createElementNS(ns, 'line');
    line.setAttribute('x1', String(startX));
    line.setAttribute('y1', String(startY));
    line.setAttribute('x2', String(startX));
    line.setAttribute('y2', String(startY));
    line.setAttribute('stroke', LINK_LINE_COLOR);
    line.setAttribute('stroke-width', '2');
    line.setAttribute('stroke-dasharray', '5 4');
    svg.appendChild(line);
    els.grid.appendChild(svg);

    linkCtx = { sourceId, startX, startY, svg, line, targetId: null };
    document.body.classList.add('linking');
    window.addEventListener('mousemove', onLinkMove);
    window.addEventListener('mouseup', endLinkDrag, { once: true });
  }

  function onLinkMove(ev) {
    if (!linkCtx || !els.grid) return;
    autoScrollIfNearEdge(ev);
    const gridRect = els.grid.getBoundingClientRect();
    const x = ev.clientX - gridRect.left;
    const y = ev.clientY - gridRect.top;
    linkCtx.line.setAttribute('x2', String(x));
    linkCtx.line.setAttribute('y2', String(y));

    const el = document.elementFromPoint(ev.clientX, ev.clientY);
    const target = el ? el.closest('[data-task-id]') : null;
    const targetId = target ? target.dataset.taskId : null;
    linkCtx.targetId = targetId && targetId !== linkCtx.sourceId ? targetId : null;
    highlightLinkTarget(linkCtx.targetId);
  }

  function endLinkDrag() {
    if (!linkCtx) return;
    const { sourceId, targetId } = linkCtx;
    if (linkCtx.svg && linkCtx.svg.parentNode) linkCtx.svg.remove();
    document.body.classList.remove('linking');
    window.removeEventListener('mousemove', onLinkMove);
    highlightLinkTarget(null);

    if (targetId && targetId !== sourceId) {
      if (wouldCreateCycle(sourceId, targetId)) {
        alert('That link would create a dependency cycle.');
      } else {
        const targetTask = getTaskById(targetId);
        if (targetTask) {
          targetTask.dependsOnId = sourceId;
          applyDependencies();
          save();
          render();
          updateDrawerContent();
          commitHistory();
        }
      }
    }
    linkCtx = null;
  }

  function render() {
    const q = els.search.value.trim().toLowerCase();
    const visibleTasks = tasks.filter(t => t.name.toLowerCase().includes(q));
    const visibleIds = new Set(visibleTasks.map(t => t.id));
    const taskIndexById = new Map(tasks.map((t, i) => [t.id, i]));
    const depWarnings = computeDependencyWarnings(taskIndexById);
    const criticalIds = showCriticalPath ? computeCriticalPathIds() : new Set();
    filteredIds = visibleIds;

    const {minD, maxD} = bounds();
    const dayCount = daysBetween(minD, addDays(maxD, 1));
    const gridWidth = Math.max(800, dayCount * dayW);
    const totalH = visibleTasks.length * ROW_H;
    const rowIndexById = new Map(visibleTasks.map((t, i) => [t.id, i]));

    els.grid.style.setProperty('--row-h', ROW_H + 'px');
    els.grid.style.setProperty('--day-w', dayW + 'px');

    renderScale(minD, dayCount, gridWidth);

    const scaleH = getScaleH();
    els.grid.style.setProperty('--scale-h', scaleH + 'px');
    const leftSpacer = document.getElementById('leftSpacer');
    if (leftSpacer) leftSpacer.style.height = scaleH + 'px';

    requestAnimationFrame(() => {
      const spacer = document.getElementById('leftSpacer');
      if (!spacer) return;
      const rightTop = els.grid.getBoundingClientRect().top;
      const leftTop = els.left.getBoundingClientRect().top;
      const delta = Math.round(rightTop - leftTop);
      if (Math.abs(delta) >= 1) spacer.style.height = (scaleH + delta) + 'px';
    });

    // Left list
    els.left.innerHTML = '';
    const paletteDotsHTML = PALETTE.map(c => `<div class="palette-dot" data-color="${escapeHtml(c)}" style="background:${escapeHtml(c)}" title="${escapeHtml(c)}"></div>`).join('');
    visibleTasks.forEach((t, idx) => {
      const visible = true;
      const li = document.createElement('li');
      li.className = `group ${visible ? '' : 'hidden'}`;
      li.draggable = true;
      li.dataset.id = t.id;
      li.dataset.taskId = t.id;
      if (showCriticalPath && criticalIds.has(t.id)) li.classList.add('critical-row');

      const s = toDate(t.start);
      const e = t.milestone ? s : toDate(t.end || t.start);
      const startVal = t.start;
      const endVal = t.milestone ? '' : (t.end || t.start);
      const durBiz = t.milestone ? null : businessDaysInclusive(s, e);
      const durTxt = t.milestone ? '—' : `${durBiz}d`;

      const curColor = t.color || (t.milestone ? DEFAULT_MILESTONE_COLOR : DEFAULT_TASK_COLOR);
      const depOptions = ['<option value="">None</option>'];
      let hasCurrent = false;
      const tIndex = taskIndexById.get(t.id);
      tasks.forEach(other => {
        if (other.id === t.id) return;
        const otherIndex = taskIndexById.get(other.id);
        if (tIndex !== undefined && otherIndex !== undefined && otherIndex >= tIndex) return;
        const rawLabel = (other.name || '').trim();
        const label = rawLabel ? rawLabel : 'Untitled task';
        const selected = other.id === t.dependsOnId ? ' selected' : '';
        if (selected) hasCurrent = true;
        depOptions.push(`<option value="${escapeHtml(other.id)}"${selected}>${escapeHtml(label)}</option>`);
      });
      if (t.dependsOnId && !hasCurrent) {
        const current = getTaskById(t.dependsOnId);
        if (current) {
          const rawLabel = (current.name || '').trim();
          const label = rawLabel ? rawLabel : 'Untitled task';
          depOptions.push(`<option value="${escapeHtml(current.id)}" selected>${escapeHtml(label)}</option>`);
        }
      }
      const depOptionsHTML = depOptions.join('');
      const depWarning = depWarnings.get(t.id);
      const depWarnHTML = depWarning ? `<span class="text-amber-500 text-xs font-semibold" title="${escapeHtml(depWarning)}">!</span>` : '';
      const endCellHTML = t.milestone
        ? '<div class="text-right text-xs md:text-sm font-mono text-gray-600 col-end">—</div>'
        : `<input type="date" class="col-end w-full text-right text-xs md:text-sm font-mono text-gray-600 bg-white border border-gray-200 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-indigo-500" data-end="true" value="${escapeHtml(endVal)}" />`;

      li.innerHTML = `
        <div class="relative">
          <div class="grid items-center px-3 task-row-grid border-b border-gray-100" style="height:${ROW_H}px; gap: 8px;">
            <div class="text-gray-400 cursor-grab" title="Drag to reorder">≡</div>
            <button type="button" class="swatch-btn" title="Change color" aria-label="Change color" draggable="false">
              <span class="swatch" style="background:${curColor}"></span>
            </button>
            <div class="flex items-center gap-2 min-w-0">
              <input class="flex-1 min-w-0 bg-transparent outline-none text-sm md:text-base task-name" />
              <button type="button" class="note-btn ${t.notes && t.notes.trim() ? 'has-notes' : ''}" title="Task notes" aria-label="Task notes" data-task-notes="true" draggable="false">N</button>
            </div>
            <div class="col-dep flex items-center gap-1">
              <select class="flex-1 text-xs md:text-sm bg-white border border-gray-200 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-indigo-500" data-deps="true" aria-label="Depends on">${depOptionsHTML}</select>
              ${depWarnHTML}
            </div>
            <input type="date" class="col-start w-full text-right text-xs md:text-sm font-mono text-gray-600 bg-white border border-gray-200 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-indigo-500" data-start="true" value="${escapeHtml(startVal)}" />
            ${endCellHTML}
            <div class="text-right text-xs md:text-sm font-mono text-gray-600 col-dur">${durTxt}</div>
            <button type="button" class="text-gray-400 hover:text-red-600" title="Delete" aria-label="Delete">✕</button>
          </div>
          <div class="palette hidden" role="menu" aria-label="Color palette">
            <div class="palette-label">Color</div>
            <div class="palette-grid">${paletteDotsHTML}</div>
          </div>
        </div>`;

      const nameInput = li.querySelector('.task-name');
      nameInput.value = t.name;
      nameInput.addEventListener('input', (e)=>{
        t.name = e.target.value;
        save();
        updateTaskNameInGantt(t);
        updateDependencyLabels(t);
        updateDrawerTaskMeta(t);
      });
      nameInput.addEventListener('blur', ()=> {
        if (els.search.value.trim()) render();
        commitHistory();
      });
      nameInput.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter') {
          e.preventDefault();
          nameInput.blur();
        }
      });
      const noteBtn = li.querySelector('button[data-task-notes]');
      if (noteBtn) {
        noteBtn.addEventListener('mousedown', (e)=> e.stopPropagation());
        noteBtn.addEventListener('dragstart', (e)=> e.preventDefault());
        noteBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          openDrawer('task', t.id);
        });
      }
      const startInput = li.querySelector('input[data-start]');
      startInput.addEventListener('change', ()=>{
        if (!applyStartInput(t, startInput.value)) return;
        applyDependencies();
        save();
        updateDrawerTaskMeta(t);
        render();
        commitHistory();
      });
      startInput.addEventListener('blur', ()=>{
        if (!applyStartInput(t, startInput.value)) return;
        applyDependencies();
        save();
        updateDrawerTaskMeta(t);
        render();
        commitHistory();
      });
      startInput.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter') {
          e.preventDefault();
          startInput.blur();
        }
      });
      const endInput = li.querySelector('input[data-end]');
      if (endInput) {
        endInput.addEventListener('change', ()=>{
          if (!applyEndInput(t, endInput.value)) return;
          applyDependencies();
          save();
          updateDrawerTaskMeta(t);
          render();
          commitHistory();
        });
        endInput.addEventListener('blur', ()=>{
          if (!applyEndInput(t, endInput.value)) return;
          applyDependencies();
          save();
          updateDrawerTaskMeta(t);
          render();
          commitHistory();
        });
        endInput.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter') {
            e.preventDefault();
            endInput.blur();
          }
        });
      }
      li.querySelector('button[aria-label="Delete"]').addEventListener('click', ()=>{
        tasks = tasks.filter(x=>x.id!==t.id);
        applyDependencies();
        save();
        render();
        updateDrawerContent();
        commitHistory();
      });
      const depSelect = li.querySelector('select[data-deps]');
      depSelect.addEventListener('change', (e)=>{
        t.dependsOnId = e.target.value || undefined;
        applyDependencies();
        save();
        render();
        updateDrawerContent();
        commitHistory();
      });

      // Color picker
      const swatchBtn = li.querySelector('.swatch-btn');
      const palette = li.querySelector('.palette');
      swatchBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        document.querySelectorAll('.palette:not(.hidden)').forEach(p=>{ if (p!==palette) p.classList.add('hidden'); });
        palette.classList.toggle('hidden');
      });
      palette.addEventListener('click', (e)=>{
        e.stopPropagation();
        const dot = e.target.closest('.palette-dot');
        if (!dot) return;
        t.color = dot.dataset.color;
        save();
        render();
        commitHistory();
      });

      // Reorder via HTML DnD
      li.addEventListener('dragstart', (e)=>{ e.dataTransfer.setData('text/plain', t.id); setTimeout(()=> li.classList.add('opacity-50'),0); });
      li.addEventListener('dragend', ()=> li.classList.remove('opacity-50'));
      li.addEventListener('dragover', (e)=>{ e.preventDefault(); li.classList.add('drop-hover'); });
      li.addEventListener('dragleave', ()=> li.classList.remove('drop-hover'));
      li.addEventListener('drop', (e)=>{
        e.preventDefault(); li.classList.remove('drop-hover');
        const draggedId = e.dataTransfer.getData('text/plain');
        if (!draggedId || draggedId===t.id) return;
        const from = tasks.findIndex(x=>x.id===draggedId);
        const to = tasks.findIndex(x=>x.id===t.id);
        const [moved] = tasks.splice(from,1);
        tasks.splice(to,0,moved);
        applyDependencies();
        save(); render();
        commitHistory();
      });

      els.left.appendChild(li);
    });

    // Grid area
    els.grid.innerHTML = '';
    els.grid.style.width = gridWidth + 'px';
    els.grid.style.height = totalH + 'px';

    // Today shading + line
    const tdy = todayUTC();
    const dayOffsetToday = daysBetween(minD, tdy);
    if (dayOffsetToday >= 0 && dayOffsetToday <= dayCount) {
      const shade = document.createElement('div');
      shade.className = 'today-col absolute';
      shade.style.top = '0px';
      shade.style.left = (dayOffsetToday * dayW) + 'px';
      shade.style.width = dayW + 'px';
      shade.style.height = totalH + 'px';
      els.grid.appendChild(shade);

      const line = document.createElement('div');
      line.className = 'today-line absolute';
      line.style.top = '0px';
      line.style.left = (dayOffsetToday * dayW) + 'px';
      line.style.height = totalH + 'px';
      els.grid.appendChild(line);
    }

    // Limit shading
    const limit = minLimitDate();
    const limitOffset = daysBetween(minD, limit);
    if (limitOffset > 0) {
      const limitShade = document.createElement('div');
      limitShade.className = 'limit-col absolute';
      limitShade.style.top = '0px';
      limitShade.style.left = '0px';
      limitShade.style.width = (limitOffset * dayW) + 'px';
      limitShade.style.height = totalH + 'px';
      els.grid.appendChild(limitShade);
    }

    // Grid background
    const gridBg = document.createElement('div');
    gridBg.className = 'gantt-grid-bg absolute';
    gridBg.style.top = '0px';
    gridBg.style.left = '0px';
    gridBg.style.width = gridWidth + 'px';
    gridBg.style.height = totalH + 'px';
    for (let i=0;i<dayCount;i++) {
      const d = addDays(minD, i);
      if (isWeekend(d)) {
        const w = document.createElement('div');
        w.className = 'weekend-shade absolute top-0';
        w.style.left = (i*dayW) + 'px';
        w.style.width = dayW + 'px';
        w.style.height = '100%';
        gridBg.appendChild(w);
      }
    }
    els.grid.appendChild(gridBg);

    // Bars + milestones
    visibleTasks.forEach((t, idx) => {
      const yBase = idx * ROW_H;
      const s = toDate(t.start);
      const e = t.milestone ? s : toDate(t.end || t.start);
      const x = daysBetween(minD, s) * dayW;
      const w = t.milestone ? 0 : Math.max(dayW, (daysBetween(s, addDays(e,1)) * dayW));

      if (t.milestone) {
        const msWrap = document.createElement('div');
        msWrap.className = 'milestone-wrap';
        msWrap.style.left = (x - 7) + 'px';
        msWrap.style.top = (yBase + (ROW_H - 14)/2) + 'px';
        msWrap.dataset.taskId = t.id;

        const ms = document.createElement('div');
        ms.className = 'milestone';
        ms.style.left = '0px';
        ms.style.top = '0px';
        ms.style.background = t.color || DEFAULT_MILESTONE_COLOR;
        ms.title = `${t.name} — ${t.start}`;
        ms.dataset.id = t.id;
        ms.dataset.taskId = t.id;
        if (showCriticalPath) {
          if (criticalIds.has(t.id)) ms.classList.add('critical-milestone');
          else ms.classList.add('non-critical');
        }

        const linkHandle = document.createElement('div');
        linkHandle.className = 'link-handle';
        linkHandle.title = 'Drag to link dependency';
        linkHandle.addEventListener('mousedown', (ev)=> startLinkDrag(ev, t.id, linkHandle));

        msWrap.appendChild(ms);
        msWrap.appendChild(linkHandle);
        ms.addEventListener('mousedown', (ev)=> startDrag(ev, t.id, 'ms-move', msWrap, minD));
        els.grid.appendChild(msWrap);
      } else {
        const bar = document.createElement('div');
        bar.className = 'bar rounded-md shadow';
        bar.style.left = x + 'px';
        bar.style.top = (yBase + (ROW_H-24)/2) + 'px';
        bar.style.height = '24px';
        bar.style.width = w + 'px';
        const bg = t.color || DEFAULT_TASK_COLOR;
        bar.style.background = bg;
        bar.title = `${t.name} — ${t.start} → ${t.end || t.start}`;
        bar.dataset.taskId = t.id;
        if (showCriticalPath) {
          if (criticalIds.has(t.id)) bar.classList.add('critical-bar');
          else bar.classList.add('non-critical');
        }

        // Optional label inside the bar (only when there's room)
        const minLabelPx = 120;
        if (w >= minLabelPx) {
          const label = document.createElement('div');
          label.className = 'bar-label';
          label.textContent = t.name;
          label.style.color = textColorForBg(bg);
          bar.appendChild(label);
        }
        bar.dataset.id = t.id;

        const linkHandle = document.createElement('div');
        linkHandle.className = 'link-handle';
        linkHandle.title = 'Drag to link dependency';
        linkHandle.addEventListener('mousedown', (ev)=> startLinkDrag(ev, t.id, linkHandle));
        bar.appendChild(linkHandle);

        const hl = document.createElement('div'); hl.className='handle-l';
        const hr = document.createElement('div'); hr.className='handle-r';
        bar.appendChild(hl); bar.appendChild(hr);

        hl.addEventListener('mousedown', (ev)=> startDrag(ev, t.id, 'resize-l', bar, minD));
        hr.addEventListener('mousedown', (ev)=> startDrag(ev, t.id, 'resize-r', bar, minD));
        bar.addEventListener('mousedown', (ev)=> {
          if (ev.target===hl || ev.target===hr) return;
          startDrag(ev, t.id, 'move', bar, minD);
        });

        els.grid.appendChild(bar);
      }
    });

    const depsLayer = renderDependencies(minD, totalH, gridWidth, rowIndexById, visibleIds);
    if (depsLayer) els.grid.appendChild(depsLayer);
  }

  function renderScale(minD, dayCount, gridWidth) {
    const months = [];
    let lastMon = fmtMon(minD);
    let curStart = 0;
    for (let i=0;i<dayCount;i++) {
      const d = addDays(minD, i);
      const mon = fmtMon(d);
      if (mon !== lastMon) {
        months.push({ label: lastMon, span: i - curStart });
        lastMon = mon; curStart = i;
      }
    }
    months.push({ label: lastMon, span: dayCount - curStart });

    const outer = document.createElement('div');
    outer.style.width = gridWidth + 'px';

    const monthRow = document.createElement('div');
    monthRow.className = 'flex border-b';
    months.forEach(m => {
      const cell = document.createElement('div');
      cell.className = 'px-2 py-1 text-[11px] text-gray-700';
      cell.style.width = (m.span * dayW) + 'px';
      cell.textContent = m.label;
      monthRow.appendChild(cell);
    });

    const daysRow = document.createElement('div');
    daysRow.className = 'flex';
    for (let i=0;i<dayCount;i++) {
      const d = addDays(minD, i);
      const cell = document.createElement('div');
      cell.className = 'text-[10px] text-gray-500 text-center';
      cell.style.width = dayW + 'px';
      cell.textContent = fmtDay(d);
      daysRow.appendChild(cell);
    }

    outer.appendChild(monthRow);
    outer.appendChild(daysRow);

    els.scale.innerHTML = '';
    els.scale.appendChild(outer);
  }

  // ===== Dragging (cursor-locked, no full render per move) =====

  function cursorContentX(ev) {
    const pane = els.rightPane;
    const rect = pane.getBoundingClientRect();
    return (ev.clientX - rect.left) + pane.scrollLeft;
  }

  function startDrag(ev, id, type, el, frozenMinD) {
    ev.preventDefault();
    const t = tasks.find(x=>x.id===id);
    if (!t) return;

    const x = cursorContentX(ev);
    const elLeftPx = el.offsetLeft;
    const elWidthPx = el.getBoundingClientRect().width;

    let anchorPx = 0;
    if (type === 'move') anchorPx = x - elLeftPx;
    else if (type === 'ms-move') anchorPx = x - (elLeftPx + 7);
    else if (type === 'resize-l') anchorPx = x - elLeftPx;
    else if (type === 'resize-r') anchorPx = x - (elLeftPx + elWidthPx);

    dragCtx = {
      type,
      id,
      el,
      minD: frozenMinD,
      startStartISO: t.start,
      startEndISO: t.end,
      anchorPx,
      pendingStartISO: t.start,
      pendingEndISO: t.end,
    };

    el.classList.add('dragging');
    document.body.style.userSelect = 'none';
    window.addEventListener('mousemove', onDragMove);
    window.addEventListener('mouseup', endDrag, { once: true });
  }

  function snapDays(deltaDays, ev) {
    const step = (ev.ctrlKey || ev.metaKey) ? 7 : (ev.shiftKey ? 5 : 1);
    return Math.round(deltaDays / step) * step;
  }

  function autoScrollIfNearEdge(ev) {
    const pane = els.rightPane;
    const rect = pane.getBoundingClientRect();
    const edge = 60;
    const speed = 28;
    if (ev.clientX < rect.left + edge) pane.scrollLeft = Math.max(0, pane.scrollLeft - speed);
    else if (ev.clientX > rect.right - edge) pane.scrollLeft += speed;
  }

  function onDragMove(ev) {
    if (!dragCtx) return;
    autoScrollIfNearEdge(ev);

    const t = tasks.find(x=>x.id===dragCtx.id);
    if (!t) return;

    const x = cursorContentX(ev);

    const minD = dragCtx.minD;
    const start0 = toDate(dragCtx.startStartISO);
    const end0 = toDate(dragCtx.startEndISO || dragCtx.startStartISO);
    const durBiz = t.milestone ? 0 : businessDaysInclusive(start0, end0);

    if (dragCtx.type === 'move' || dragCtx.type === 'ms-move') {
      const desiredStartLeftPx = x - dragCtx.anchorPx;
      const desiredStartDay = desiredStartLeftPx / dayW;
      const startDay0 = daysBetween(minD, start0);
      const snappedStartDay = startDay0 + snapDays(desiredStartDay - startDay0, ev);

      let newStart = addDays(minD, snappedStartDay);
      newStart = clampStartToLimit(newStart);

      if (t.milestone || dragCtx.type === 'ms-move') {
        dragCtx.pendingStartISO = toISO(newStart);
        dragCtx.el.style.left = ((daysBetween(minD, newStart) * dayW) - 7) + 'px';
      } else {
        const bizLen = Math.max(1, durBiz);
        const newEnd = addBusinessDays(newStart, bizLen - 1);
        dragCtx.pendingStartISO = toISO(newStart);
        dragCtx.pendingEndISO = toISO(newEnd);
        dragCtx.el.style.left = (daysBetween(minD, newStart) * dayW) + 'px';
      }
      return;
    }

    if (dragCtx.type === 'resize-l') {
      const desiredLeftPx = x - dragCtx.anchorPx;
      const desiredDay = desiredLeftPx / dayW;
      const startDay0 = daysBetween(minD, start0);
      const snappedDay = startDay0 + snapDays(desiredDay - startDay0, ev);

      let newStart = addDays(minD, snappedDay);
      newStart = clampStartToLimit(newStart);
      if (newStart > end0) newStart = end0;

      dragCtx.pendingStartISO = toISO(newStart);

      const newLeftPx = daysBetween(minD, newStart) * dayW;
      const endRightPx = daysBetween(minD, end0) * dayW + dayW;
      dragCtx.el.style.left = newLeftPx + 'px';
      dragCtx.el.style.width = Math.max(dayW, endRightPx - newLeftPx) + 'px';
      return;
    }

    if (dragCtx.type === 'resize-r') {
      const desiredRightPx = x - dragCtx.anchorPx;
      const desiredDay = desiredRightPx / dayW;
      const endDay0 = daysBetween(minD, end0);
      const snappedDay = endDay0 + snapDays(desiredDay - endDay0, ev);

      let newEnd = addDays(minD, snappedDay);
      newEnd = snapEndToBusinessDay(newEnd);
      if (newEnd < start0) newEnd = start0;

      dragCtx.pendingEndISO = toISO(newEnd);

      const leftPx = daysBetween(minD, start0) * dayW;
      const rightPx = daysBetween(minD, newEnd) * dayW + dayW;
      dragCtx.el.style.width = Math.max(dayW, rightPx - leftPx) + 'px';
      return;
    }
  }

  function endDrag() {
    window.removeEventListener('mousemove', onDragMove);
    document.body.style.userSelect = '';

    if (!dragCtx) return;

    const t = tasks.find(x=>x.id===dragCtx.id);
    if (t) {
      if (dragCtx.pendingStartISO) t.start = dragCtx.pendingStartISO;
      if (!t.milestone && dragCtx.pendingEndISO) t.end = dragCtx.pendingEndISO;
      updateDrawerTaskMeta(t);
    }

    dragCtx.el?.classList.remove('dragging');
    dragCtx = null;

    applyDependencies();
    save();
    render();
    commitHistory();
  }

  function addTask(defaultMilestone=false) {
    const base = snapStartToBusinessDay(todayUTC());
    const s = toISO(base);
    if (defaultMilestone) {
      tasks.push({
        id: uid(),
        name: 'New Milestone',
        start: s,
        milestone: true,
        color: DEFAULT_MILESTONE_COLOR
      });
    } else {
      const end = toISO(addBusinessDays(base, 5-1));
      tasks.push({
        id: uid(),
        name: 'New Task',
        start: s,
        end,
        milestone: false,
        color: DEFAULT_TASK_COLOR
      });
    }
    save();
    render();
    commitHistory();
    requestAnimationFrame(()=>{
      const li = document.querySelector('#taskList li:last-child input');
      if (li) { li.focus(); li.select(); }
    });
  }

  // ===== Resizable splitter =====
  (function initSplitter(){
    const ui = loadUI();
    if (ui && typeof ui.leftW === 'number') setLeftWidth(ui.leftW, false);
    else {
      const cur = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--left-w'), 10) || 560;
      applyLeftLayout(clampLeftWidth(cur));
    }

    let resizing = false;
    let startX = 0;
    let startW = 0;

    function onMove(e) {
      if (!resizing) return;
      const dx = e.clientX - startX;
      setLeftWidth(startW + dx, false);
    }
    function onUp() {
      if (!resizing) return;
      resizing = false;
      document.body.classList.remove('no-select','col-resize');
      const cur = getComputedStyle(document.documentElement).getPropertyValue('--left-w').trim();
      const px = parseInt(cur.replace('px',''), 10);
      if (Number.isFinite(px)) saveUI({ leftW: clampLeftWidth(px) });
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    }

    els.splitter?.addEventListener('mousedown', (e)=>{
      e.preventDefault();
      resizing = true;
      startX = e.clientX;
      const cur = getComputedStyle(document.documentElement).getPropertyValue('--left-w').trim();
      startW = parseInt(cur.replace('px',''), 10) || 560;
      document.body.classList.add('no-select','col-resize');
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    });

    els.splitter?.addEventListener('dblclick', ()=>{
      const cur = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--left-w'), 10) || 560;
      const target = cur < 520 ? 680 : 480;
      setLeftWidth(target, true);
    });
  })();

  (function initZoom(){
    const ui = loadUI();
    if (ui && ui.zoom && ZOOM_LEVELS[ui.zoom]) {
      zoomKey = ui.zoom;
      dayW = ZOOM_LEVELS[zoomKey].dayW;
    }
    updateZoomButtons();
    zoomButtons.forEach(btn => {
      btn.addEventListener('click', ()=> setZoom(btn.dataset.zoom, true));
    });
  })();

  (function initCriticalToggle(){
    const ui = loadUI();
    if (ui && typeof ui.criticalPath === 'boolean') {
      showCriticalPath = ui.criticalPath;
    }
    updateCriticalToggle();
    els.criticalToggle?.addEventListener('click', ()=>{
      showCriticalPath = !showCriticalPath;
      saveUI({ criticalPath: showCriticalPath });
      updateCriticalToggle();
      render();
    });
  })();

  // ===== Events =====
  els.search.addEventListener('input', render);
  els.notesBtn?.addEventListener('click', ()=> openDrawer('project'));
  els.drawerClose?.addEventListener('click', closeDrawer);
  els.drawerOverlay?.addEventListener('click', closeDrawer);

  if (els.projectNotesInput) {
    els.projectNotesInput.addEventListener('input', ()=>{
      projectNotes = els.projectNotesInput.value;
      saveMeta({ notes: projectNotes });
    });
    els.projectNotesInput.addEventListener('blur', ()=> {
      commitHistory();
    });
  }
  if (els.taskNotesInput) {
    els.taskNotesInput.addEventListener('input', ()=>{
      const t = getTaskById(drawerState.taskId);
      if (!t) return;
      t.notes = els.taskNotesInput.value;
      save();
      updateTaskNoteBadge(t.id);
    });
    els.taskNotesInput.addEventListener('blur', ()=> {
      commitHistory();
    });
  }

  if (els.projectTitle) {
    els.projectTitle.addEventListener('input', () => {
      const title = els.projectTitle.value.trim() || 'Project name';
      document.title = title + ' — Gantt';
      saveMeta({ title });
    });
    els.projectTitle.addEventListener('blur', ()=> {
      commitHistory();
    });
    els.projectTitle.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') {
        e.preventDefault();
        els.projectTitle.blur();
      }
    });
  }

  els.addTask.addEventListener('click', ()=> addTask(false));
  els.addMilestone.addEventListener('click', ()=> addTask(true));
  els.share.addEventListener('click', sharePortable);
  els.undoBtn.addEventListener('click', undo);
  els.redoBtn.addEventListener('click', redo);

  // Kebab menu
  els.menuBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    els.menu.classList.toggle('hidden');
  });
  document.addEventListener('click', ()=> {
    els.menu.classList.add('hidden');
    document.querySelectorAll('.palette:not(.hidden)').forEach(p=>p.classList.add('hidden'));
  });
  els.menu.addEventListener('click', (e)=> e.stopPropagation());

  els.clearData.addEventListener('click', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    els.menu.classList.add('hidden');
    if (!confirm('This will permanently delete all project data on this device. Continue?')) return;
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(META_KEY);
    localStorage.removeItem(UI_KEY);
    clearShareHash();
    resetSearch();
    projectNotes = '';
    tasks = [];
    save();
    if (els.projectTitle) {
      els.projectTitle.value = 'Project name';
      document.title = 'Project name — Gantt';
    }
    if (els.projectNotesInput) els.projectNotesInput.value = '';
    updateDrawerContent();
    render();
    commitHistory();
  });

  els.loadSample.addEventListener('click', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    els.menu.classList.add('hidden');
    if (!confirm('Load the sample project and overwrite current data?')) return;
    localStorage.removeItem(STORAGE_KEY);
    clearShareHash();
    resetSearch();
    tasks = sampleTasks();
    applyDependencies();
    save();
    render();
    updateDrawerContent();
    commitHistory();
  });
  els.importCsv.addEventListener('click', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    els.menu.classList.add('hidden');
    if (els.importCsvInput) {
      els.importCsvInput.value = '';
      els.importCsvInput.click();
    }
  });
  if (els.importCsvInput) {
    els.importCsvInput.addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => importCsv(reader.result);
      reader.onerror = () => alert('Failed to read CSV file.');
      reader.readAsText(file);
    });
  }
  els.exportCsv.addEventListener('click', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    els.menu.classList.add('hidden');
    exportCsv();
  });

  els.todayBtn.addEventListener('click', ()=> scrollToDate(todayUTC(), 'left'));
  els.centerTodayBtn.addEventListener('click', ()=> scrollToDate(todayUTC(), 'center'));

  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && drawerState.open) {
      e.preventDefault();
      closeDrawer();
      return;
    }
    const inField = e.target.closest('input, textarea, select');
    const isMod = e.ctrlKey || e.metaKey;
    if (!inField && isMod && (e.key === 'z' || e.key === 'Z')) {
      e.preventDefault();
      if (e.shiftKey) redo();
      else undo();
      return;
    }
    if (!inField && isMod && (e.key === 'y' || e.key === 'Y')) {
      e.preventDefault();
      redo();
      return;
    }
    if (!inField && (e.key === 't' || e.key === 'T')) {
      e.preventDefault();
      scrollToDate(todayUTC(), 'center');
    }
  });

  // Vertical sync left/right
  const leftPane = document.getElementById('leftPane');
  leftPane.addEventListener('scroll', ()=> { els.rightPane.scrollTop = leftPane.scrollTop; });
  els.rightPane.addEventListener('scroll', ()=> { leftPane.scrollTop = els.rightPane.scrollTop; });

  // Init
  load();
  render();
  scrollToDate(todayUTC(), 'center');
  commitHistory();

})();
</script>
</body>
</html>
